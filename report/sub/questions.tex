\section{Réponse aux questions}

\subsection{Politique d'ordonnancement}
Le rôle d'un ordonnanceur est de résoudre le problème de ressources partagées.
Dans le cas d'un RTOS la ressource centrale est le(s) cœur(s) de processeur.
La question étant, sur quels éléments se baser pour déterminer quelle tâche peut y accéder.
Il existe un grand nombre de choix bien documenté dans la littérature.
La politique implémentée dans FreeRTOS est l'ordonnancement préemptif à priorités fixes (Fixed priority pre-emptive scheduling).
Dans le cas de priorité identique un round-robin est appliqué.
Afin de s'approprier le code du noyau, il est demandé d'\textit{identifier la procédure en charge de la politique d’ordonnancement en faisant le lien avec les constantes définies dans le fichier FreeRTOSConfig.h.
Quelle(s) procédure(s) faudrait-il modifier pour changer la politique ?}
\gap

Les procédures liées à l'ordonnancement sont définies dans le fichier \texttt{task.c}.
Parmi elles, on retrouve \texttt{vTaskSwitchContext()}.
Qui, comme son nom l'indique, assure le changement de contexte des taches.
Mais, avant de faire le changement effectif, elle doit identifier la tache la plus prioritaire.
Le bloc de code suivant est extrait de la fonction.
\begin{lstlisting}[style=CStyle]
    /* Select a new task to run using either the generic C or port optimised asm code. */
    taskSELECT_HIGHEST_PRIORITY_TASK();
\end{lstlisting}
Ainsi, pour être plus précis, c'est la macro \texttt{taskSELECT\_HIGHEST\_PRIORITY\_TASK} qui est en charge d'appliquer la politique de préemption à priorité fixe.
Si on souhaite la changer il faut la remplacer.
Dans le cas d'un système temps réel cela n'est pas simple car il faut probablement, pour atteindre de bonnes performances, écrire le code en assembleur.
Il est toutefois, possible d'ajuster la politique avec les paramètres de configuration mis à disposition.
En effet, il est possible de désactiver la préemption dans \texttt{config.h} avec \texttt{configUSE\_PREEMPTION}
Aussi, les priorités dites fixes, car non modifié par le RTOS, sont en fait modifiable durant l'exécution.
Cela aura pour résultat d'influencer la politique.

\subsection{Gestion de la mémoire}
Le noyau du RTOS a besoin de RAM chaque fois qu'une tâche, une file de message, un mutex, un délai logiciel, un sémaphore ou un groupe d'événements est créé. 
La RAM peut être automatiquement allouée dynamiquement à partir du tas, ou elle peut être fournie par le développeur.
La question posée est la suivante :
\textit{Qu’impliquent les 5 politiques de gestion de la mémoire par FreeRTOS ?}
\gap

FreeRTOS offre plusieurs schémas de gestion du tas qui varient en complexité et en fonctionnalités.
Il est possible d'utiliser deux politiques de gestion mémoire simultanément.
Cela permet par exemple, aux piles des tâches et aux autres objets du RTOS d'être placés dans la RAM interne rapide, et aux données de l'application d'être placées dans la RAM externe plus lente \cite{web_freeRTOS_heap}.

\noindent
\textbf{heap 1} \\
C'est le fonctionnement le plus simple, il ne permet pas de libérer de la mémoire une fois allouée.
Malgré cela, il convient à la majorité des applications temps réel.
En effet, quand les contraintes mémoire sont rudes, il est usuel de déclarer les taches et objets RTOS statiquement au démarrage.
Le programme de heap 1 divise une zone mémoire en petits blocs.
La taille globale étant donnée par \texttt{configTOTAL\_HEAP\_SIZE}.

\noindent
\textbf{heap 2} \\
Le second mode propose une fonctionnalité supplémentaire, il permet de libérer de la mémoire, mais ne permet pas la fusion de blocs libres adjacents.
Il peut être utilisé dans le cas où l'application affecte de la mémoire dynamiquement en connaissance des risques.
En effet, la taille des blocs alloués doit être constante sans quoi la mémoire risque de se fragmenter au cours de l'exécution et finir par causer une erreur d'allocation.

\noindent
\textbf{heap 3} \\
Ce mode est bien différent des autres puisqu'il encapsule des fonctions standard \texttt{malloc}() et \texttt{free}().
L'environnement de compilation doit contenir le code de ces deux fonctions.
Les inconvénients à cela sont le non-déterminisme de l'exécution et l'occupation mémoire.
En effet, d'un appel à l'autre le temps d'exéction de \texttt{malloc} et \texttt{free} diffère.

\noindent
\textbf{heap 4} \\
Ce schéma s'apparente au heap 2 avec en plus la fusion des blocs libres adjacents pour éviter la fragmentation.
Cela le rend lui aussi non déterministe.
Il reste cependant bien plus performant que la plupart des implantations de \texttt{malloc}.

\noindent
\textbf{heap 5} \\
Le cinquième est dernier mode de gestion est le plus avancées mis à disposition par FreeRTOS.
Il propose de la possibilité d'étendre le tas (heap) à travers plusieurs zones de mémoire non adjacentes.


\subsection{Fréquence de clignotement}
% La réponse à la question posée en fin du paragraphe 4.3.

\textit{Comment faire varier la fréquence de clignotement de la LED ? (plusieurs possibilités)}
